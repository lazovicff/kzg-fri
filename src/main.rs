use bls12_381::Scalar;
use fri::FRI;
use kzg::KzgCommitmentScheme;
use poly::Polynomial;
use rand::thread_rng;

mod fri;
mod kzg;
mod merkle;
mod poly;
mod utils;

fn kzg() {
    let mut rng = thread_rng();
    let kzg = KzgCommitmentScheme::trusted_setup(5, &mut rng);

    // Create polynomial p(x) = 2 + 3x + x^2
    let polynomial = Polynomial::new(vec![
        Scalar::from(2u64),
        Scalar::from(3u64),
        Scalar::from(1u64),
    ]);

    // Commit to polynomial
    let commitment = kzg.commit(&polynomial);

    // Single-point evaluation example
    let challenge = Scalar::from(4u64);
    let value = polynomial.evaluate(&challenge);
    let proof = kzg.prove(&polynomial, &challenge);

    let is_valid = kzg.verify(&commitment, &challenge, &value, &proof);
    println!("KZG verification: {}", is_valid);
    assert!(is_valid);
}

fn fri() {
    // polynomial of f(x) = 19 + 56x + 34x^2 + 48x^3 + 43x^4 + 37x^5 + 10x^6 + 0x^7
    let poly = vec![19, 56, 34, 48, 43, 37, 10, 0]
        .into_iter()
        .map(|x| Scalar::from(x))
        .collect();
    let poly = Polynomial::new(poly);
    let mut fri = FRI::new(4);

    // commit phase
    println!("Generating FRI proofs...");
    // the random values are generated by the verifier (in reality this will be fiat shamir transformation)
    let random_values = vec![12, 32, 64]
        .into_iter()
        .map(|x| Scalar::from(x))
        .collect();
    let commitments = fri.commit(poly, random_values);
    println!("Commitments: {:?}", commitments);

    // query phase
    let random_index = 4;
    let proofs = fri.query(random_index);

    // verify phase
    let result = fri.verify(proofs);
    println!("FRI verification {result}");
}

fn main() {
    kzg();
    fri();
}
