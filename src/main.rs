use bls12_381::Scalar;
use ff::Field;
use fri::{FRIProver, FRIVerifier};
use kzg::{KZGProver, KZGTrustedSetup, KZGVerifier};
use poly::{MultivariatePolynomial, Polynomial};
use rand::{Rng, thread_rng};
use std::time::Instant;
use sumcheck::{SumcheckProver, SumcheckVerifier};

mod fri;
mod kzg;
mod merkle;
mod poly;
mod sumcheck;
mod utils;

fn kzg_benchmark() {
    println!("=== KZG Benchmark ===");
    let mut rng = thread_rng();

    // Test with polynomial of degree 1023 (2^10 - 1)
    let degree = 1023;

    // Trusted setup timing
    let start = Instant::now();
    let setup = KZGTrustedSetup::new(degree, &mut rng);
    let setup_time = start.elapsed();
    println!(
        "KZG Trusted Setup Time (degree {}): {:?}",
        degree, setup_time
    );

    // Create large random polynomial
    let coeffs: Vec<Scalar> = (0..=degree).map(|_| Scalar::random(&mut rng)).collect();
    let polynomial = Polynomial::new(coeffs);

    let prover = KZGProver::new(setup.clone());

    // Commit timing
    let start = Instant::now();
    let commitment = prover.commit(&polynomial);
    let commit_time = start.elapsed();
    println!("KZG Commit Time: {:?}", commit_time);

    // Proving timing
    let challenge = Scalar::random(&mut rng);
    let value = polynomial.evaluate(&challenge);

    let start = Instant::now();
    let proof = prover.prove(&polynomial, &challenge);
    let prove_time = start.elapsed();
    println!("KZG Prove Time: {:?}", prove_time);

    // Verification timing
    let verifier = KZGVerifier::new(setup);

    let start = Instant::now();
    let is_valid = verifier.verify(&commitment, &challenge, &value, &proof);
    let verify_time = start.elapsed();
    println!("KZG Verify Time: {:?}", verify_time);
    println!("KZG Verification Result: {}", is_valid);
    assert!(is_valid);
    println!();
}

fn fri_benchmark() {
    println!("=== FRI Benchmark ===");
    let mut rng = thread_rng();

    // Test with polynomial of degree 1023 (2^10 - 1, requires 10 folding rounds)
    let degree = 1023;
    let num_rounds = 10; // log2(1024) = 10

    // Create large random polynomial with 1024 coefficients (degree 1023)
    let coeffs: Vec<Scalar> = (0..1024).map(|_| Scalar::random(&mut rng)).collect();
    let poly = Polynomial::new(coeffs);

    let mut prover = FRIProver::new(4); // blowup factor of 4

    // Generate random values for folding (one per round)
    let random_values: Vec<Scalar> = (0..num_rounds).map(|_| Scalar::random(&mut rng)).collect();

    // Commit phase timing
    let start = Instant::now();
    let commitments = prover.commit(poly, random_values.clone());
    let commit_time = start.elapsed();
    println!("FRI Commit Time (degree {}): {:?}", degree, commit_time);

    // Query phase timing
    let random_index = rng.gen_range(0..1024);

    let start = Instant::now();
    let proofs = prover.query(random_index);
    let prove_time = start.elapsed();
    println!("FRI Prove Time: {:?}", prove_time);

    // Verification timing
    let verifier = FRIVerifier::new(random_values, commitments);

    let start = Instant::now();
    let result = verifier.verify(proofs);
    let verify_time = start.elapsed();
    println!("FRI Verify Time: {:?}", verify_time);
    println!("FRI Verification Result: {}", result);
    assert!(result);
    println!();
}

fn kzg_small() {
    println!("=== Small KZG Example ===");
    let mut rng = thread_rng();
    let setup = KZGTrustedSetup::new(5, &mut rng);

    // Create polynomial p(x) = 2 + 3x + x^2
    let polynomial = Polynomial::new(vec![
        Scalar::from(2u64),
        Scalar::from(3u64),
        Scalar::from(1u64),
    ]);

    // Commit to polynomial
    let prover = KZGProver::new(setup.clone());
    let commitment = prover.commit(&polynomial);

    // Single-point evaluation example
    let challenge = Scalar::from(4u64);
    let value = polynomial.evaluate(&challenge);
    let proof = prover.prove(&polynomial, &challenge);

    let verifier = KZGVerifier::new(setup);
    let is_valid = verifier.verify(&commitment, &challenge, &value, &proof);
    println!("KZG verification: {}", is_valid);
    assert!(is_valid);
    println!();
}

fn fri_small() {
    println!("=== Small FRI Example ===");
    // polynomial of f(x) = 19 + 56x + 34x^2 + 48x^3 + 43x^4 + 37x^5 + 10x^6 + 0x^7
    let poly = vec![19, 56, 34, 48, 43, 37, 10, 0]
        .into_iter()
        .map(|x| Scalar::from(x))
        .collect();
    let poly = Polynomial::new(poly);
    let mut prover = FRIProver::new(4);

    // commit phase
    println!("Generating FRI proofs...");
    // the random values are generated by the verifier (in reality this will be fiat shamir transformation)
    let random_values: Vec<Scalar> = vec![12, 32, 64]
        .into_iter()
        .map(|x| Scalar::from(x))
        .collect();
    let commitments = prover.commit(poly, random_values.clone());
    println!("Commitments: {:?}", commitments);

    // query phase
    let random_index = 4;
    let proofs = prover.query(random_index);

    // verify phase
    let verifier = FRIVerifier::new(random_values, commitments);
    let result = verifier.verify(proofs);
    println!("FRI verification: {}", result);
    println!();
}

fn sumcheck_demo() {
    println!("=== Sumcheck Protocol Demo ===");
    let mut rng = thread_rng();

    // Create a simple 3-variable polynomial for demonstration
    let num_vars = 3;
    let _size = 1 << num_vars; // 2^3 = 8 evaluations

    // Define polynomial f(x1, x2, x3) with specific evaluations
    let evaluations = vec![
        Scalar::from(1u64), // f(0,0,0) = 1
        Scalar::from(2u64), // f(0,0,1) = 2
        Scalar::from(3u64), // f(0,1,0) = 3
        Scalar::from(4u64), // f(0,1,1) = 4
        Scalar::from(5u64), // f(1,0,0) = 5
        Scalar::from(6u64), // f(1,0,1) = 6
        Scalar::from(7u64), // f(1,1,0) = 7
        Scalar::from(8u64), // f(1,1,1) = 8
    ];

    let poly = MultivariatePolynomial::new(num_vars, evaluations);
    let claimed_sum = poly.sum(); // Sum = 1+2+3+4+5+6+7+8 = 36

    println!("Polynomial has {} variables", num_vars);
    // Generate random challenges (in practice these come from verifier/Fiat-Shamir)
    let challenges: Vec<Scalar> = (0..num_vars).map(|_| Scalar::random(&mut rng)).collect();

    // Prover generates proof
    let start = Instant::now();
    let prover = SumcheckProver::new(poly.clone());
    let proof = prover.prove(claimed_sum, &challenges);
    let prove_time = start.elapsed();
    println!("Sumcheck Prove Time: {:?}", prove_time);
    println!(
        "Proof contains {} round polynomials",
        proof.round_polynomials.len()
    );

    // Verifier checks the proof
    let start = Instant::now();
    let verifier = SumcheckVerifier::new(num_vars, claimed_sum);
    let is_valid = verifier.verify_with_challenges(proof, &challenges);
    let verify_time = start.elapsed();
    println!("Sumcheck Verify Time: {:?}", verify_time);
    println!("Sumcheck Verification Result: {}", is_valid);

    println!();
}

fn sumcheck_benchmark() {
    println!("=== Sumcheck Benchmark ===");
    let mut rng = thread_rng();

    // Test with larger polynomial (10 variables = 1024 evaluations)
    let num_vars = 10;

    let start = Instant::now();
    let poly = MultivariatePolynomial::random(num_vars, &mut rng);
    let setup_time = start.elapsed();
    println!(
        "Random polynomial setup (2^{} evaluations): {:?}",
        num_vars, setup_time
    );

    let claimed_sum = poly.sum();
    let challenges: Vec<Scalar> = (0..num_vars).map(|_| Scalar::random(&mut rng)).collect();

    // Proving time
    let start = Instant::now();
    let prover = SumcheckProver::new(poly);
    let proof = prover.prove(claimed_sum, &challenges);
    let prove_time = start.elapsed();
    println!("Sumcheck Prove Time ({} vars): {:?}", num_vars, prove_time);

    // Verification time
    let start = Instant::now();
    let verifier = SumcheckVerifier::new(num_vars, claimed_sum);
    let is_valid = verifier.verify_with_challenges(proof, &challenges);
    let verify_time = start.elapsed();
    println!("Sumcheck Verify Time: {:?}", verify_time);
    println!("Sumcheck Verification Result: {}", is_valid);
    assert!(is_valid);
    println!();
}

fn main() {
    // Run small examples first
    kzg_small();
    fri_small();
    sumcheck_demo();

    // Run benchmarks with large polynomials
    kzg_benchmark();
    fri_benchmark();
    sumcheck_benchmark();
}
