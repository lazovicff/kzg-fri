use bls12_381::Scalar;
use fri::{FRIProver, FRIVerifier};
use kzg::{KZGProver, KZGTrustedSetup, KZGVerifier};
use poly::Polynomial;
use rand::thread_rng;

mod fri;
mod kzg;
mod merkle;
mod poly;
mod utils;

fn kzg() {
    let mut rng = thread_rng();
    let setup = KZGTrustedSetup::new(5, &mut rng);

    // Create polynomial p(x) = 2 + 3x + x^2
    let polynomial = Polynomial::new(vec![
        Scalar::from(2u64),
        Scalar::from(3u64),
        Scalar::from(1u64),
    ]);

    // Commit to polynomial
    let prover = KZGProver::new(setup.clone());
    let commitment = prover.commit(&polynomial);

    // Single-point evaluation example
    let challenge = Scalar::from(4u64);
    let value = polynomial.evaluate(&challenge);
    let proof = prover.prove(&polynomial, &challenge);

    let verifier = KZGVerifier::new(setup);
    let is_valid = verifier.verify(&commitment, &challenge, &value, &proof);
    println!("KZG verification: {}", is_valid);
    assert!(is_valid);
}

fn fri() {
    // polynomial of f(x) = 19 + 56x + 34x^2 + 48x^3 + 43x^4 + 37x^5 + 10x^6 + 0x^7
    let poly = vec![19, 56, 34, 48, 43, 37, 10, 0]
        .into_iter()
        .map(|x| Scalar::from(x))
        .collect();
    let poly = Polynomial::new(poly);
    let mut prover = FRIProver::new(4);

    // commit phase
    println!("Generating FRI proofs...");
    // the random values are generated by the verifier (in reality this will be fiat shamir transformation)
    let random_values: Vec<Scalar> = vec![12, 32, 64]
        .into_iter()
        .map(|x| Scalar::from(x))
        .collect();
    let commitments = prover.commit(poly, random_values.clone());
    println!("Commitments: {:?}", commitments);

    // query phase
    let random_index = 4;
    let proofs = prover.query(random_index);

    // verify phase
    let verifier = FRIVerifier::new(random_values, commitments);
    let result = verifier.verify(proofs);
    println!("FRI verification {result}");
}

fn main() {
    kzg();
    fri();
}
